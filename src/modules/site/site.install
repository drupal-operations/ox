<?php

/**
 * @file
 * Install, update and uninstall functions for the Site module.
 */

use Drupal\Core\Entity\EntityDefinitionUpdateManagerInterface;
use Drupal\Core\Field\BaseFieldDefinition;

/**
 * Implements hook_install().
 */
function site_install() {

  // Ok this is crazy.
  // This should not be necessary, but...
  // See site_entity_field_storage_info()
  // See site_entity_field_storage_info call allPropertyFieldDefinitions
  // See allPropertyFieldDefinitions return ALL fields from ALL bundles.
  // See allPropertyFieldDefinitions return NO FIELDS when installing site.module.
  // See empty $bundles = $EntityTypeBundleInfo->getBundleInfo($entity_type->id());
  // Every time.
  // Had to use debugging and install via the extend form to figure this out. :D

  // So this hack just reinstalls all the fields.
  // This is the fastest way I could figure out how to do this.
  // Stolen from DevelEntityDefinitionUpdateManager

  // reinstall storage
  $changes = \Drupal::entityDefinitionUpdateManager()
    ->getChangeList();

  // @TODO: Move to something.
  foreach ($changes as $entity_type_id => $change_list) {
    // Process entity type definition changes before storage definitions ones
    // this is necessary when you change an entity type from non-revisionable
    // to revisionable and at the same time add revisionable fields to the
    // entity type.
    if (!empty($change_list['entity_type'])) {
      //$this->doEntityUpdate($change_list['entity_type'], $entity_type_id);
      \Drupal::entityDefinitionUpdateManager()
        ->updateEntityType($change_list['entity_type']);
    }

    // Process field storage definition changes.
    if (!empty($change_list['field_storage_definitions'])) {

      $storage_definitions = \Drupal::service('entity_field.manager')->getFieldStorageDefinitions($entity_type_id);
      $original_storage_definitions = \Drupal::service('entity.last_installed_schema.repository')->getLastInstalledFieldStorageDefinitions($entity_type_id);

      foreach ($change_list['field_storage_definitions'] as $field_name => $change) {
        $storage_definition = isset($storage_definitions[$field_name]) ? $storage_definitions[$field_name] : NULL;
        $original_storage_definition = isset($original_storage_definitions[$field_name]) ? $original_storage_definitions[$field_name] : NULL;
        //$this->doFieldUpdate($change, $storage_definition, $original_storage_definition);

        $op = $change;
        switch ($op) {
          case EntityDefinitionUpdateManagerInterface::DEFINITION_CREATED:
            \Drupal::service('field_storage_definition.listener')->onFieldStorageDefinitionCreate($storage_definition);
            break;

          case EntityDefinitionUpdateManagerInterface::DEFINITION_UPDATED:
            if ($storage_definition && $original_storage_definition) {
              \Drupal::service('field_storage_definition.listener')->onFieldStorageDefinitionUpdate($storage_definition, $original_storage_definition);
            }
            break;

          case EntityDefinitionUpdateManagerInterface::DEFINITION_DELETED:
            if ($original_storage_definition) {
              \Drupal::service('field_storage_definition.listener')->onFieldStorageDefinitionDelete($original_storage_definition);
            }
            break;
        }

      }
    }
  }

  // @TODO: I would create a site entity here... but when enabled during an install profile,
  // the module is enabled BEFORE site title and URL are available... so.... just clear caches for first entity??
}

/**
 * Implements hook_uninstall().
 */
function site_uninstall() {
}

/**
 * Install site_root composer_json and drupal_env fields.
 */
function site_update_8001() {
  $fields['drupal_env'] = BaseFieldDefinition::create('string')
    ->setLabel(t('Drupal Environment'))
    ->setDescription(t('The value of the DRUPAL_ENV environment variable.'))
    ->setRevisionable(TRUE)
    ->setDisplayConfigurable('view', TRUE)
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'string',
    ])
  ;
  $fields['site_root'] = BaseFieldDefinition::create('string')
    ->setLabel(t('Root path'))
    ->setDescription(t('The root path of this site.'))
    ->setRevisionable(TRUE)
    ->setDisplayConfigurable('view', TRUE)
    ->setDisplayOptions('view', [
      'label' => 'above',
      'type' => 'string',
    ])
  ;
  $fields['composer_json'] = BaseFieldDefinition::create('map')
    ->setLabel(t('Composer.json Data'))
    ->setRevisionable(TRUE)
    ->setDisplayConfigurable('view', TRUE)
  ;
  foreach ($fields as $name => $field) {
    Drupal::entityDefinitionUpdateManager()
      ->installFieldStorageDefinition($name, 'site', 'site', $field);
  }
}

/**
 * Install api_key field on Drupal Project entity.
 */
function site_update_8002() {
  $fields['api_key'] = BaseFieldDefinition::create('string')
    ->setLabel(t('API Key'))
    ->setDescription(t('An API Key from the site. If entered, site data from here will post back to the client site when saving this form.'))
    ->setRevisionable(TRUE)
    ->setDisplayOptions('form', [
      'type' => 'string_textfield',
    ])
    ->setDisplayConfigurable('form', TRUE)
  ;
  foreach ($fields as $name => $field) {
    Drupal::entityDefinitionUpdateManager()
      ->installFieldStorageDefinition($name, 'drupal_project', 'drupal_project', $field);
  }
}


/**
 * Remove composer_json field. Plugin stores in data field now.
 *
 * For some reason, this field was breaking basic website creation.
 */
function site_update_8003() {
  $definition_manager = \Drupal::entityDefinitionUpdateManager();
  $field_storage_definition = $definition_manager->getFieldStorageDefinition('composer_json', 'site');
  $definition_manager->uninstallFieldStorageDefinition($field_storage_definition);
}

